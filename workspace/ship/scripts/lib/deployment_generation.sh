#!/usr/bin/env bash
# deployment_generation.sh - Generate deployment scripts for different environments
# Extracted from release_ops.sh and broken into smaller, focused functions

set -euo pipefail

# Variables will be checked when functions are called (defined in core.sh)

############################################################################
# Deployment Script Generation - Create environment-specific startup scripts
############################################################################

# Generate the script header with environment configuration
generate_script_header() {
  local env="$1"
  cat << EOF
#!/usr/bin/env bash
#-------------------------------------------------------------
# start-${env}.sh - Self-contained ${env} environment deployment
# Generated by build-ship - DO NOT EDIT MANUALLY
#-------------------------------------------------------------
set -euo pipefail

# Environment Configuration (Type-5: Zero Entropy)
ENVIRONMENT="$ENVIRONMENT"
DEPLOYMENT_ROOT="\$(pwd)"
NETWORK_NAME="$NETWORK_NAME"
CONTAINER_NAME="$CONTAINER_NAME"
VAULTWARDEN_NAME="$VAULTWARDEN_NAME"

# Port Configuration
HTTP_PORT=$HTTP_PORT
HTTPS_PORT=$HTTPS_PORT
VAULTWARDEN_PORT=$VAULTWARDEN_PORT

# Network Configuration  
NETWORK_SUBNET="$NETWORK_SUBNET"
NGINX_IP="$NGINX_IP"
VAULTWARDEN_IP="$VAULTWARDEN_IP"

# Docker Image
IMAGE="nginx:latest"

echo "ðŸš€ Starting \$ENVIRONMENT environment"
echo "   Container: \$CONTAINER_NAME"
echo "   Network: \$NETWORK_NAME (\$NETWORK_SUBNET)"
echo "   Ports: HTTP=\$HTTP_PORT, HTTPS=\$HTTPS_PORT"
EOF
}

# Generate network creation logic
generate_network_setup() {
  cat << 'EOF'

# Create deterministic network if it doesn't exist
if ! docker network ls | grep -q "\$NETWORK_NAME"; then
  echo "Creating network: \$NETWORK_NAME (\$NETWORK_SUBNET)"
  docker network create "\$NETWORK_NAME" --subnet="\$NETWORK_SUBNET"
else
  echo "Network \$NETWORK_NAME already exists"
fi
EOF
}

# Generate service discovery and startup logic
generate_service_discovery() {
  cat << 'EOF'

# Auto-discover and start services from conf.d
echo "Auto-discovering services from conf.d/*.conf files"
for conf_file in "\$DEPLOYMENT_ROOT/conf.d"/*.conf; do
  [[ -f "\$conf_file" ]] || continue
  
  service_name=$(basename "\$conf_file" .conf)
  service_container="\${service_name}-\${ENVIRONMENT}"
  
  # Extract upstream references to start dependent services
  if grep -q "proxy_pass.*\${service_name}-" "\$conf_file"; then
    echo "  â†’ Found service: \$service_name"
    
    # Start service container if not running
    if ! docker ps | grep -q "\$service_container"; then
      echo "    Starting \$service_container"
      
      docker stop "\$service_container" 2>/dev/null || true
      docker rm "\$service_container" 2>/dev/null || true
      
      # Create service-specific data directory
      mkdir -p "\$DEPLOYMENT_ROOT/data/\$service_name-\$ENVIRONMENT"
      
      # Determine service port (auto-increment from base)
      case "\$service_name" in
        vaultwarden) service_port=\$VAULTWARDEN_PORT ;;
        *) service_port=\$((VAULTWARDEN_PORT + 100)) ;;  # Auto-assign ports
      esac
      
      # Start service container
      docker run -d \
        --name "\$service_container" \
        --network "\$NETWORK_NAME" \
        --ip "\$VAULTWARDEN_IP" \
        -p "\$service_port:80" \
        -v "\$DEPLOYMENT_ROOT/data/\$service_name-\$ENVIRONMENT:/data" \
        -e WEBSOCKET_ENABLED=true \
        \${service_name}/server:latest 2>/dev/null || \
      docker run -d \
        --name "\$service_container" \
        --network "\$NETWORK_NAME" \
        --ip "\$VAULTWARDEN_IP" \
        -p "\$service_port:80" \
        -v "\$DEPLOYMENT_ROOT/data/\$service_name-\$ENVIRONMENT:/data" \
        nginx:latest
        
      echo "    âœ… \$service_container started on port \$service_port"
    else
      echo "    \$service_container already running"
    fi
    
    # Update service references in nginx config
    sed -i "s/\$service_name-ship:/\$service_container:/g" "\$DEPLOYMENT_ROOT/conf.d/\$service_name.conf"
    sed -i "s/\$service_name-[a-zA-Z]*:/\$service_container:/g" "\$DEPLOYMENT_ROOT/conf.d/\$service_name.conf"
  fi
done
EOF
}

# Generate nginx container startup logic
generate_nginx_startup() {
  cat << 'EOF'

# Stop nginx container if already running
docker stop "\$CONTAINER_NAME" 2>/dev/null || true
docker rm "\$CONTAINER_NAME" 2>/dev/null || true

echo "Starting \$CONTAINER_NAME on \$NETWORK_NAME network"

# Start nginx container
docker run -d \
  --name "\$CONTAINER_NAME" \
  --network "\$NETWORK_NAME" \
  --ip "\$NGINX_IP" \
  -p "\$HTTP_PORT:80" \
  -p "\$HTTPS_PORT:443" \
  -v "\$DEPLOYMENT_ROOT/nginx.conf:/etc/nginx/nginx.conf:ro" \
  -v "\$DEPLOYMENT_ROOT/conf.d:/etc/nginx/conf.d:ro" \
  -v "\$DEPLOYMENT_ROOT/certs:/etc/nginx/certs:ro" \
  -v "\$DEPLOYMENT_ROOT/info_pages:/var/www/info_pages:ro" \
  -v "\$DEPLOYMENT_ROOT/nginx-logs:/var/www/NgNix-RP/nginx-logs" \
  "\$IMAGE"

echo "âœ… \$ENVIRONMENT environment started successfully!"
echo "   URLs: http://localhost:\$HTTP_PORT, https://localhost:\$HTTPS_PORT"
echo "   Logs: docker logs \$CONTAINER_NAME"
EOF
}

# Generate health check and validation logic
generate_health_check() {
  cat << 'EOF'

# Test nginx configuration
sleep 2
if docker ps | grep -q "\$CONTAINER_NAME"; then
  echo "âœ… \$CONTAINER_NAME is running"
  docker logs "\$CONTAINER_NAME" --tail 5 2>/dev/null || true
else
  echo "âŒ \$CONTAINER_NAME failed to start"
  docker logs "\$CONTAINER_NAME" 2>/dev/null || true
  exit 1
fi
EOF
}

# Main function to generate complete deployment script
generate_deployment_script() {
  local env="$1"
  local ship_dir="$2"
  local script_file="$ship_dir/start-${env}.sh"
  
  # Set defaults before loading environment configuration
  DEPLOYMENT_ROOT="/opt/nginx-rp"
  ENVIRONMENT="$env"
  
  # Load and calculate deterministic values
  source "$WORKSPACE_ROOT/environments/base/calculate_deterministic_values.sh"
  calculate_deterministic_values
  
  log_info "  â†’ Generating start-${env}.sh"
  
  # Generate the complete script by combining all parts
  {
    generate_script_header "$env"
    generate_network_setup
    generate_service_discovery  
    generate_nginx_startup
    generate_health_check
  } > "$script_file"
  
  chmod +x "$script_file"
}

# Generate README.md for ship package
generate_ship_readme() {
  local ship_dir="$1"
  
  cat > "$ship_dir/README.md" << 'EOF'
# Self-Contained Deployment Package

This package contains everything needed to deploy to any Type-5 environment.

## Usage

### Local Ship Environment (testing)
```bash
./start-ship.sh
```

### Stage Environment (IONOS staging)
```bash
./start-stage.sh
```

### Pre-production Environment
```bash
./start-preprod.sh
```

### Production Environment
```bash
./start-prod.sh
```

## What's Included

- Runtime configurations (nginx.conf, conf.d/*)
- SSL certificates
- Info pages
- Environment-specific deployment scripts
- Zero-entropy deterministic deployment

## Adding New Services

1. Add service configuration to `conf.d/servicename.conf`
2. Add SSL certificates to `certs/domain.com/`
3. Add info pages to `info_pages/domain.com/`
4. Deployment scripts automatically discover and configure new services

No script modifications needed!
EOF
}

# Generate all deployment scripts for ship package
generate_all_deployment_scripts() {
  local ship_dir="$1"
  
  log_info "Generating deployment scripts for Type-5 environments"
  
  for env in ship stage preprod prod; do
    generate_deployment_script "$env" "$ship_dir"
  done
  
  generate_ship_readme "$ship_dir"
}